---
title: "movie_recommendation"
author: "Sean Cranston"
date: "6/24/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(recommenderlab)
library(tidyverse)                   
library(data.table)
library(reshape2)
```


```{r Data_import}

movie_data <- read_csv("movies.csv",
                       col_types = cols(
                         movieId = col_double(),
                         title = col_character(),
                         genres = col_character()
                       ))
rating_data <- read_csv("ratings.csv",
                        col_types = cols(
                          userId = col_double(),
                          movieId = col_double(),
                          rating = col_double(),
                          timestamp = col_double()
                        ))
```


# Data Processing

```{r genre_matrix}
names_genre <- c("Action", "Adventure", "Animation", "Children", "Comedy", "Crime",
           "Documentary", "Drama", "Fantasy", "Film-Noir", "Horror", "Musical", 
           "Mystery","Romance", "Sci-Fi", "Thriller", "War", "Western")
list_genre <- str_split(movie_data$genres, "[|]")

genre = matrix(0, nrow(movie_data), ncol = length(names_genre)) %>% 
    `colnames<-`(names_genre) 
    
for (row in 1:nrow(genre)) { #can't seem to write a function to continue the pipe :(
    for (col in 1:ncol(genre)) {
        genre[row,col] = ifelse(any(names_genre[col] == list_genre[[row]]), 1, 0)
    }
}

genre = as.data.frame(genre)
str(genre)

SearchMatrix <- cbind(movie_data[,1:2], genre[])
head(SearchMatrix)
```



#creating a sparse matrix for rating_data
```{r rating_matrix}
ratingMatrix <- reshape2::dcast(rating_data, 
                                userId~movieId, 
                                value.var = "rating", 
                                na.rm=FALSE) %>% 
    select(-c('userId')) %>% 
    as.matrix() %>% #needs to be matrix to convert to sparse matrix
    as(.,"realRatingMatrix") 
#Convert rating matrix into a recommenderlab sparse matrix 
dim(rating_data %>% dcast(userId~movieId,value.var = "rating",na.rm=F))
dim(ratingMatrix)
getRatingMatrix(ratingMatrix) %>% head()
```




# exploring similar data
```{r data_explore}
similarity_mat <- similarity(ratingMatrix[1:100 ], #get 100 users 
                             method = "cosine",
                             which = "users") #similar based on user
as.matrix(similarity_mat)
image(as.matrix(similarity_mat), main = "User's Similarities")




movie_similarity <- similarity(ratingMatrix[, 1:100],
                               method = "cosine",
                               which = "items") %>%  #similar based on movie
    as.matrix()
image(as.matrix(movie_similarity), main = "Movies similarity")



table_of_ratings <- as.vector(ratingMatrix@data) %>% 
    # extracting unique ratings
    #unique() %>%  
    table()
table_of_ratings

ratings <- table_of_ratings %>% as.data.frame()
ggplot(ratings[-c(1),],
       aes(x = ., y = Freq)) +
  geom_col()
ggplot(ratings,
       aes(x = ., y = Freq)) +
  geom_col()
```


# Most viewed visualization
```{r Visualizations}
table_view <- ratingMatrix %>% 
  colCounts() %>% 
  data.frame(movie = names(.),
             views = .) %>% 
  arrange(desc(views)) %>% 
  mutate(title = NA)
for (index in 1:10325){ #add title to table_views
  table_view[index,3] <- as.character(
    subset(movie_data,
           movie_data$movieId == table_view[index,1])$title)
}
table_view[1:6,]

ggplot(table_view[1:6,], aes(x = title, y = views))+
    geom_bar( stat="identity",fill = 'steelblue') +
    geom_text(aes(label=views), vjust=-0.3, size=3.5) +
    theme_bw()+
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    ggtitle("Total Views of the Top Films")+
    ylim(0, 350)
    

# Heatmap of movie ratings

image(ratingMatrix[1:25,1:25], 
      axes = FALSE, 
      main = "Heatmap of the first 25 rows and 25 columns")

```



#Data Preparation
```{r data_processing}
movie_ratings <- ratingMatrix[rowCounts(ratingMatrix) > 50,
                              colCounts(ratingMatrix) > 50]
movie_ratings
dim(ratingMatrix) #got rid of a lot of movies


minimum_movies<- quantile(rowCounts(movie_ratings), 0.98)
# 98th percentile of how many movies a user rated
minimum_users <- quantile(colCounts(movie_ratings), 0.98)
image(movie_ratings[rowCounts(movie_ratings) > minimum_movies,
                    #we only want users that rated more movies than the lower 98%
                    colCounts(movie_ratings) > minimum_users],
      main = "Heatmap of the top users and movies")



average_ratings <- rowMeans(movie_ratings)
qplot(average_ratings, fill=I("steelblue"), col=I("red")) +
    ggtitle("Distribution of the average rating per user")


#####
#normalizing

normalized_ratings <- normalize(movie_ratings)
sum(rowMeans(normalized_ratings) > 0.00001)

image(normalized_ratings[rowCounts(normalized_ratings) > minimum_movies,
                         colCounts(normalized_ratings) > minimum_users],
      main = "Normalized Ratings of the Top Users")



#####
# Data Binarization

binary_minimum_movies <- quantile(rowCounts(movie_ratings), 0.95)
#I think they changed this to .95 so their would be more white spaces
binary_minimum_users <- quantile(colCounts(movie_ratings), 0.95)
#movies_watched <- binarize(movie_ratings, minRating = 1)
#binarize <- 
good_rated_films <- binarize(movie_ratings, minRating = 3)
image(good_rated_films[rowCounts(movie_ratings) > binary_minimum_movies,
                       colCounts(movie_ratings) > binary_minimum_users],
      main = "Heatmap of the top users and movies")



summary(movie_ratings@data) %>% head()
```



# adjusting parameters/options
```{r model_options}
recommendation_model <- recommenderRegistry$get_entries(
  dataType = "realRatingMatrix")
names(recommendation_model)

#ask about how latent factors are used, what might they be
lapply(recommendation_model, "[[", "description") 

recommendation_model$IBCF_realRatingMatrix$parameters
recommenderRegistry$get_entries(dataType = "realRatingMatrix")
```



# Building recommendation system in R 

```{r 4model_RMSE}

e <-  evaluationScheme(movie_ratings, #evaluate will normalize for us
                       method="cross", 
                       k = 3,#three fold cross validation
                       given=3, 
                       goodRating=3)#>= 0 is a good rating for normalized data
e

Models_to_be <- list("UBCF_C" = list(name = "UBCF", 
                                     param = list(method = "cosine")),
                     "IBCF_C" = list(name = "IBCF",
                                     param = list(method = "cosine")),
                     "UBCF_P" = list(name = "UBCF",#not working :(
                                     param = list(method = "pearson")),
                     "IBCF_P" = list(name = "IBCF",
                                     param = list(method = "pearson")),
                     "SVD" = list(name = "SVD"),
                     "rand" = list(name = "RANDOM"))

Models_results <- evaluate(e,
                      Models_to_be,
                      #type = "ratings",
                      # type = "topNList",
                      n = c(1,3,5,10*1:10)
                      )
Models_results
#results_c$UBCF_C@results
# results_c
# names(results_c)
#results_c[["UBCF_C"]]

plot(Models_results, annotate=c(1,3), legend = "bottomright") #ROC curve
plot(Models_results, "prec/rec", annotate = 3, legend = "topleft") #precision recall curve

#getConfusionMatrix(Models_results$UBCF_C) #gives RMSE,MSE, and MAE

avg_conf <- function(results) {
  tmp <- results %>%
    getConfusionMatrix()
  as.data.frame(Reduce("+",tmp) / length(tmp))
}

Models_avg <- Models_results %>%
  map(avg_conf)
Models_avg

P <- predict(Models_results$UBCF_C, getData(e,"known"))

# manuals example
r1 <- Recommender(getData(e,"train"),"UBCF")
r1

r2 <- Recommender(getData(e,"train"),"IBCF")
r2

p1 <- predict(r1,getData(e,"known"), type = "ratings")
p1

p2 <- predict(r2, getData(e,"known"), type = "ratings")
p2

error <- rbind(
  UBCF = calcPredictionAccuracy(p1, getData(e, "unknown")),
  IBCF = calcPredictionAccuracy(p2, getData(e, "unknown"))
)
error

```


### 5.7 (evaluation of a top-N recommender algorithm)
```{r}

scheme <- evaluationScheme(normalized_ratings,
                           method = "cross-validation",
                           k = 10, # 3 fold cross validation
                           given = 3,
                           goodRating = 0) #>= 3 is a good rating
scheme

results <- evaluate(scheme,
                    method = "IBCF",
                    # type = "topNList",
                    # n = c(1,3,5,10,15,20,500)
                    )
results

getConfusionMatrix(results)[[1]] #confusion matrix for the n runs in column form


avg(results) #average for all runs above

# plot(results, annotate = T)
# plot(results, "prec/rec", annotate = T)

```


```{r Mengshi}
# scheme <- movie_ratings %>% 
#   evaluationScheme(method = "cross-validation",
#                                 k = 10,
#                                 given = 3,
#                                 goodRating = 3)
# 
# models_to_evaluate <- list(
#   `IBCF Cosinus` = list(name = "IBCF", 
#                         param = list(method = "cosine")),
#   `IBCF Pearson` = list(name = "IBCF", 
#                         param = list(method = "pearson")),
#   `UBCF Cosinus` = list(name = "UBCF",
#                         param = list(method = "cosine")),
#   `UBCF Pearson` = list(name = "UBCF",
#                         param = list(method = "pearson")),
#   `SVD` = list(name="SVD"),
#   `Random` = list(name = "RANDOM", param=NULL)
# )
# 
# n_recommendations <- c(1, 5, seq(10, 100, 10))
# 
# 
# list_results <- evaluate(x = scheme, 
#                          method = models_to_evaluate, 
#                          n = n_recommendations)
# 
# avg_conf_matr <- function(results) {
#   tmp <- results %>%
#     getConfusionMatrix()  %>%  
#     as.list() 
#   as.data.frame(Reduce("+",tmp) / length(tmp)) %>% 
#     mutate(n_recommendations) %>%
#     select('n', 'precision', 'recall', 'TPR', 'FPR') 
# }

results_tbl <- list_results %>%
  map(avg_conf_matr) %>% 
  # Turning into an unnested tibble
  enframe() %>%
  # Unnesting to have all variables on same level
  unnest(cols = c(value))

results_tbl
```




# Building reco sys by splitting
```{r}

sampled_data<- sample(x = c(T, F),
                      size = nrow(movie_ratings),
                      replace = T,
                      prob = c(0.8, 0.2))
training_data <- movie_ratings[sampled_data, ]
testing_data <- movie_ratings[!sampled_data, ]


recommen_model <- Recommender(data = training_data,
                              method = "IBCF",
                              parameter = list(k = 30))#this is defualt
recommen_model
class(recommen_model)

```

# model exploring

```{r model exploring}

model_info <- getModel(recommen_model)
class(model_info$sim)
dim(model_info$sim)
top_items <- 20
image(model_info$sim[1:top_items, 1:top_items],
      main = "Heatmap of the first rows and columns")

sum_rows <- rowSums(model_info$sim > 0)
#user has to have a movie that it is similar to 
table(sum_rows) #does 447 users have 30 movies in common?


#how many movies(y-axis) had sum_cols count views(or ratings)
#for 20 movies there was 50 views(or cumulative ratings)
sum_cols <- colSums(model_info$sim > 0)
qplot(sum_cols, fill=I("steelblue"), col=I("red"))+ 
  ggtitle("Distribution of the column count")

```



# predict
```{r}

top_recommendations <- 10 # the number of items to recommend to each user
predicted_recommendations <- predict(object = recommen_model,
                                     newdata = testing_data,
                                     n = top_recommendations)
predicted_recommendations



user1 <- predicted_recommendations@items[[1]] 
# recommendation for the first user
movies_user1 <- predicted_recommendations@itemLabels[user1]
movies_user2 <- movies_user1
for (index in 1:10){
  movies_user2[index] <- as.character(
    subset(movie_data,movie_data$movieId == movies_user1[index])$title)
}
movies_user2



recommendation_matrix <- sapply(predicted_recommendations@items,
                                function(x){ 
                                  as.integer(colnames(movie_ratings)[x]) 
                                }) 
# matrix with the recommendations for each user
#dim(recc_matrix)
recommendation_matrix[,1:4]



#first unspecified output
number_of_items <- factor(table(recommendation_matrix))
chart_title <- "Distribution of the Number of Items for IBCF"
qplot(number_of_items, fill=I("steelblue"), col=I("red")) + 
  ggtitle(chart_title)


#second unspecified output
number_of_items_sorted <- sort(number_of_items, decreasing = TRUE)
number_of_items_top <- head(number_of_items_sorted, n = 4)
table_top <- data.frame(as.integer(names(number_of_items_top)),
                        number_of_items_top)
for(i in 1:4) {
  table_top[i,1] <- as.character(subset(movie_data,
                                        movie_data$movieId == table_top[i,1])$title)
}
colnames(table_top) <- c("Movie Title", "No. of Items")
table_top

```




